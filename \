var ReactBootstrap = require('react-bootstrap');
var React = require('react');
var Button = ReactBootstrap.Button;
var Glyphicon = ReactBootstrap.Glyphicon;
var Well = ReactBootstrap.Well;
var $ = require('jquery');
var jsDiff = require('diff');

var File = React.createClass({
  getInitialState: function() {
    return {
      code : ''
    };
  },

  componentWillMount: function() {
    var currentFile = this.props.filePaths[this.props.currentPath];
    var url = currentFile.raw_url;
    var prevUrl = currentFile.last_url || url;
    $.get(prevUrl)
    .always(function(prevData) { //for each tick of commitIndex, we get the previous data again...why?? refactor
      //always is workaround for now, this goes to the .error if encounters JS (but data in responseText)
      prevData = prevData.responseText || prevData || '';
      $.get(url)
      .always(function(data) {
        data = data.responseText || data;
        this.diff(data,prevData,url);
      }.bind(this));
    }.bind(this));
  },

  diff: function(data, pdata, url) {
    debugger;
    if (typeof data === 'object') {
      data = JSON.stringify(data);
      pdata = JSON.stringify(pdata);
    }
    var diff = jsDiff.diffWords(pdata, data);
    this.setState ( {code: this.codeOr(diff, url)} );
  },

  formattedData: function(data, fileType) {
    //if (typeof data === 'object') return JSON.stringify(data); //something something json
    //if (typeof data === 'string' && fileType !== 'json') return data;
    if (typeof data === 'string') return data;
    function color(part) {
      return {color: part.added ? 'green' : part.removed ? 'red' : 'grey'};
    };
    return data.map(function(part) {
      return (
        <span style={color(part)}>{part.value}</span>
      )
    });

  },
  codeOr: function(data, url) {
    var fileType = this.props.currentPath.split('.').pop();
    if (fileType === 'png' || fileType === 'gif' || fileType === 'jpg' || fileType === 'jpeg') {
      return (
        <Well bsSize='small'>
        <img src={url}/>
        </Well>
      )
    } else {
      var style = {
        wordWrap: 'break-word; white-space; pre-wrap'
      }
      debugger;
        return (
          <pre style={style}>
          //{data}
          {this.formattedData(data, fileType)}
          </pre>
        )
    }
  },
  render: function () {
    return (
      <div>
      {this.state.code}
      </div>
    )
  }
});

module.exports = File;
